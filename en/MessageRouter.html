
<!DOCTYPE HTML>
<html lang="en" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Message routers Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="ChannelProtocol.html" />
    
    
    <link rel="prev" href="./" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2" data-path="MessageRouter.html">
            
                <a href="MessageRouter.html">
            
                    
                    Message routers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="ChannelProtocol.html">
            
                <a href="ChannelProtocol.html">
            
                    
                    Channels and Protocols
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Message routers</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="message-routers">Message routers</h1>
<p>The first step in using Arteria is to create the primary and secondary routers. Regardless of calling them with such names, both routers are
actually equal and perform identically. The only difference is in the channel identity numbering scheme to avoid conflicts. Before a router
can be instantiated, we need to provide a <code>MessageRouterHandler</code> for it. The router handler takes care of application specific activity such
as instantiating new channels under the router.</p>
<p>The <code>MessageRouterHandler[MaterializeChild]</code> takes a type parameter describing the type to deliver channel materialization information to
the counterpart router. Typically this is represented as a sealed hierarchy of case classes where each class corresponds to a type of
channel that can be created. In this documentation we will be using two top level channels, <em>log</em> and <em>UI</em>, so our type hierarchy looks
like this:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouterMessage</span></span>

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">CreateLogChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RouterMessage</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">CreateUIChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RouterMessage</span></span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">RouterMessage</span> </span>{
  <span class="hljs-keyword">val</span> defaultRouterPickler = compositePickler[<span class="hljs-type">RouterMessage</span>]
    .addConcreteType[<span class="hljs-type">CreateLogChannel</span>.<span class="hljs-keyword">type</span>]
    .addConcreteType[<span class="hljs-type">CreateUIChannel</span>.<span class="hljs-keyword">type</span>]
}
</code></pre>
<p>We also define a pickler for the router messages by utilizing Boopickle&apos;s <code>compositePickler</code>.</p>
<p>Next we&apos;ll define the handler with a minimal implementation.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> arteria.core._

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopChannelHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageRouterHandler</span>[<span class="hljs-type">RouterMessage</span>] </span>{
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">materializeChildChannel</span></span>(id: <span class="hljs-type">Int</span>,
                                       globalId: <span class="hljs-type">Int</span>,
                                       router: <span class="hljs-type">MessageRouterBase</span>,
                                       materializeChild: <span class="hljs-type">RouterMessage</span>,
                                       contextReader: <span class="hljs-type">ChannelReader</span>): <span class="hljs-type">MessageChannelBase</span> = {
    materializeChild <span class="hljs-keyword">match</span> {
      <span class="hljs-keyword">case</span> <span class="hljs-type">CreateLogChannel</span> =&gt; ??? <span class="hljs-comment">// todo</span>
      <span class="hljs-keyword">case</span> <span class="hljs-type">CreateUIChannel</span>     =&gt; ??? <span class="hljs-comment">// todo</span>
    }
  }
}
</code></pre>
<p>Now we are ready to instantiate the router.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> handlerPri = <span class="hljs-keyword">new</span> <span class="hljs-type">TopChannelHandler</span>
<span class="hljs-keyword">val</span> routerPri = <span class="hljs-keyword">new</span> <span class="hljs-type">MessageRouter</span>(handlerPri, isPrimary = <span class="hljs-literal">true</span>)
</code></pre>
<p>On the other side of the fence we&apos;ll do the same for the secondary router</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> handlerSec = <span class="hljs-keyword">new</span> <span class="hljs-type">TopChannelHandler</span>
<span class="hljs-keyword">val</span> routerSec = <span class="hljs-keyword">new</span> <span class="hljs-type">MessageRouter</span>(handlerSec, isPrimary = <span class="hljs-literal">false</span>)
</code></pre>
<h2 id="transport">Transport</h2>
<p>As stated in the introduction, Arteria core doesn&apos;t provide any transport mechanism of its own, the routers simply produce and consume
<code>ByteBuffer</code>s. In this simplified example we just pass these buffers directly from one router to the other. To get a stream of pending
messages, call the <code>flush</code> method and to pass this stream to the other router, use the <code>receive</code> method.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> dataPri = routerPri.flush()
routerSec.receive(dataPri)
<span class="hljs-keyword">val</span> dataSec = routerSec.flush()
routerPri.receive(dataSec)
</code></pre>
<p>The first thing routers do is to send an <code>EstablishRoute</code> message to the other router, establishing the channel between them and making sure
they agree on who&apos;s the primary router.</p>
<p>The transport implementation can check for pending messages by calling router&apos;s <code>hasPending</code> method before calling <code>flush</code>. Even when there
are no pending messages, a call to <code>flush</code> will produce a valid <code>ByteBuffer</code> that can be sent to the other router (albeit containing no
messages). Alternatively the application can listen to the <code>messagesPending</code> callback in the router handler, which is called after a message
has been queued to be flushed. In typical usage scenarios it makes sense to periodically check for pending messages either by having a
constant timer running or by starting a (short) timer after a callback to <code>messagesPending</code> is received. This improves performance as
messages sent in a short period of time are kept together and flushed to the other router as a single stream.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="./" class="navigation navigation-prev " aria-label="Previous page: Introduction">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="ChannelProtocol.html" class="navigation navigation-next " aria-label="Next page: Channels and Protocols">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Message routers","level":"1.2","depth":1,"next":{"title":"Channels and Protocols","level":"1.3","depth":1,"path":"ChannelProtocol.md","ref":"ChannelProtocol.md","articles":[]},"previous":{"title":"Introduction","level":"1.1","depth":1,"path":"README.md","ref":"README.md","articles":[]},"dir":"ltr"},"config":{"plugins":["editlink","highlight","github"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"editlink":{"label":"Edit This Page","multilingual":false,"base":"https://github.com/suzaku-io/arteria/tree/master/doc"},"github":{"url":"https://github.com/suzaku-io/arteria/"},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{"version":"0.1.0-SNAPSHOT"},"language":"en","gitbook":"*"},"file":{"path":"MessageRouter.md","mtime":"2017-01-28T22:19:11.009Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2017-01-28T22:49:37.463Z"},"basePath":".","book":{"language":"en"}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-editlink/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

